<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>NEO-CORE ASSAULT</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #0a0a1a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            position: fixed;
        }

        #gameContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #canvasWrapper {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            flex: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #gameCanvas {
            background: #000;
            z-index: 1;
            width: 100%;
            height: 100%;
        }

        #uiCanvas {
            z-index: 2;
            pointer-events: none;
            width: 100%;
            height: 100%;
        }

        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 20, 30, 0.98);
            border: none;
            padding: 20px;
            text-align: center;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
        }

        #gameOver {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(30, 0, 0, 0.98);
            border: none;
            padding: 20px;
            text-align: center;
            z-index: 10;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        h1 {
            color: #00ff00;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ff00;
            line-height: 1.2;
            padding: 0 10px;
        }

        h2 {
            color: #ff00ff;
            margin: 15px 0;
            font-size: 1.8em;
        }

        .menu-content {
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 15px 20px;
            margin: 10px auto;
            font-size: 1.1em;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            max-width: 280px;
            border-radius: 5px;
            display: block;
            touch-action: manipulation;
        }

        button:hover, button:active {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 20px #00ff00;
        }

        #instructions {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 20, 30, 0.98);
            border: none;
            padding: 20px;
            z-index: 10;
            display: none;
            overflow-y: auto;
        }

        .instructions-content {
            text-align: left;
            line-height: 1.6;
            padding: 20px;
            max-width: 600px;
            margin: 0 auto;
        }

        .key {
            display: inline-block;
            background: #002200;
            border: 1px solid #00ff00;
            padding: 3px 10px;
            margin: 0 5px;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .color-sample {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin: 0 5px;
            vertical-align: middle;
            border: 1px solid #fff;
            border-radius: 3px;
        }

        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #330000;
            color: #ff0000;
            border: 2px solid #ff0000;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 11;
        }

        #pauseScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 30, 0.98);
            border: none;
            padding: 20px;
            text-align: center;
            z-index: 10;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #highScores {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 10, 0, 0.98);
            border: none;
            padding: 20px;
            z-index: 10;
            display: none;
            overflow-y: auto;
        }

        #highScoresList {
            list-style: none;
            margin: 20px 0;
            padding: 0;
        }

        #highScoresList li {
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 153, 0, 0.1);
            border: 1px solid #ff9900;
            border-radius: 5px;
            font-size: 1.1em;
        }

        #mobileControls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            z-index: 3;
            display: none;
            justify-content: space-between;
            padding: 15px;
            pointer-events: none;
        }

        .mobile-control-group {
            display: flex;
            gap: 20px;
            pointer-events: auto;
        }

        .mobile-btn {
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
            border-radius: 50%;
            color: #00ff00;
            font-size: 22px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.9;
            user-select: none;
            touch-action: manipulation;
            -webkit-user-select: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: all 0.1s;
        }

        .mobile-btn:active {
            background: rgba(0, 255, 0, 0.7);
            transform: scale(0.95);
        }

        .movement-controls {
            position: fixed;
            left: 20px;
            bottom: 20px;
            z-index: 3;
            display: none;
            pointer-events: none;
        }

        .joystick {
            width: 140px;
            height: 140px;
            background: rgba(0, 100, 255, 0.2);
            border: 2px solid #0066ff;
            border-radius: 50%;
            position: relative;
            pointer-events: auto;
        }

        .joystick-handle {
            width: 60px;
            height: 60px;
            background: rgba(0, 150, 255, 0.5);
            border: 2px solid #0099ff;
            border-radius: 50%;
            position: absolute;
            top: 40px;
            left: 40px;
            transition: transform 0.1s;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            
            h2 {
                font-size: 1.5em;
            }
            
            button {
                padding: 12px 15px;
                font-size: 1em;
                max-width: 250px;
            }
            
            .mobile-btn {
                width: 60px;
                height: 60px;
                font-size: 18px;
            }
            
            .joystick {
                width: 120px;
                height: 120px;
            }
            
            .joystick-handle {
                width: 50px;
                height: 50px;
                top: 35px;
                left: 35px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }
            
            h2 {
                font-size: 1.3em;
            }
            
            button {
                padding: 10px 12px;
                font-size: 0.9em;
                max-width: 220px;
            }
            
            .instructions-content {
                padding: 15px;
                font-size: 0.9em;
            }
            
            .mobile-btn {
                width: 55px;
                height: 55px;
                font-size: 16px;
            }
            
            .joystick {
                width: 100px;
                height: 100px;
            }
            
            .joystick-handle {
                width: 45px;
                height: 45px;
                top: 27.5px;
                left: 27.5px;
            }
        }

        /* Landscape mode adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            #menu, #gameOver, #pauseScreen {
                padding: 10px;
                justify-content: flex-start;
                padding-top: 40px;
            }
            
            h1 {
                font-size: 1.8em;
                margin-bottom: 10px;
            }
            
            button {
                padding: 8px 12px;
                margin: 5px auto;
                max-width: 200px;
            }
            
            #mobileControls {
                bottom: 10px;
                padding: 10px;
            }
            
            .movement-controls {
                bottom: 10px;
                left: 10px;
            }
        }

        /* Prevent text selection */
        * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Prevent blue highlight on tap */
        *:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="canvasWrapper">
            <canvas id="gameCanvas"></canvas>
            <canvas id="uiCanvas"></canvas>
        </div>
        
        <div id="menu">
            <div class="menu-content">
                <h1>NEO-CORE ASSAULT</h1>
                <button onclick="startGame()">START GAME</button>
                <button onclick="showInstructions()">HOW TO PLAY</button>
                <button onclick="showHighScores()">HIGH SCORES</button>
            </div>
        </div>
        
        <div id="instructions">
            <button class="close-btn" onclick="closeInstructions()">X</button>
            <div class="instructions-content">
                <h2>HOW TO PLAY</h2>
                <p><span class="key">TOUCH JOYSTICK</span> - Move</p>
                <p><span class="key">DRAG ON SCREEN</span> - Aim</p>
                <p><span class="key">FIRE BUTTON</span> - Shoot</p>
                <p><span class="key">SPECIAL BUTTON</span> - Special Ability</p>
                <p><span class="key">DASH BUTTON</span> - Dash</p>
                <br>
                <h3>ENEMY TYPES:</h3>
                <p><span class="color-sample" style="background: #ff0000;"></span> DRONE - Basic follower</p>
                <p><span class="color-sample" style="background: #ff00ff;"></span> SENTINEL - Stationary shooter</p>
                <p><span class="color-sample" style="background: #ffff00;"></span> CHARGER - Fast melee</p>
                <p><span class="color-sample" style="background: #00ffff;"></span> CARRIER - Spawns drones</p>
                <br>
                <h3>FRAGMENT TYPES:</h3>
                <p>Collect 3 of same color to unlock special ability</p>
                <p><span class="color-sample" style="background: #ff3333;"></span> RED - Missile Launcher</p>
                <p><span class="color-sample" style="background: #3333ff;"></span> BLUE - Shield Burst</p>
                <p><span class="color-sample" style="background: #33ff33;"></span> GREEN - Laser Beam</p>
            </div>
        </div>
        
        <div id="highScores">
            <button class="close-btn" onclick="closeHighScores()">X</button>
            <div class="instructions-content">
                <h2>HIGH SCORES</h2>
                <ul id="highScoresList"></ul>
            </div>
        </div>
        
        <div id="gameOver">
            <div class="menu-content">
                <h2>MISSION FAILED</h2>
                <p id="finalScore" style="font-size: 1.2em; margin: 10px 0;">Score: 0</p>
                <p id="finalWave" style="font-size: 1.2em; margin: 10px 0;">Wave: 1</p>
                <button onclick="restartGame()">RETRY</button>
                <button onclick="showMenu()">MENU</button>
            </div>
        </div>
        
        <div id="pauseScreen">
            <div class="menu-content">
                <h2>GAME PAUSED</h2>
                <button onclick="resumeGame()">RESUME</button>
                <button onclick="restartGame()">RESTART</button>
                <button onclick="showMenu()">MENU</button>
            </div>
        </div>
        
        <div class="movement-controls" id="movementControls">
            <div class="joystick" id="joystick">
                <div class="joystick-handle" id="joystickHandle"></div>
            </div>
        </div>
        
        <div id="mobileControls">
            <div class="mobile-control-group">
                <div class="mobile-btn" id="dashBtn" ontouchstart="mobileDash(true)" ontouchend="mobileDash(false)">DASH</div>
                <div class="mobile-btn" id="specialBtn" ontouchstart="mobileSpecial(true)" ontouchend="mobileSpecial(false)">PWR</div>
            </div>
            <div class="mobile-control-group">
                <div class="mobile-btn" id="fireBtn" ontouchstart="mobileShoot(true)" ontouchend="mobileShoot(false)">FIRE</div>
            </div>
        </div>
    </div>

    <script>
// ============================================
// NEO-CORE ASSAULT - Mobile Optimized Game
// ============================================

// Game Constants - Now dynamic based on screen size
let CANVAS_WIDTH, CANVAS_HEIGHT;
const PLAYER_SPEED = 5;
const PLAYER_RADIUS = 20;
const PLAYER_MAX_HEALTH = 100;
const PLAYER_MAX_SHIELD = 50;
const SHIELD_REGEN_RATE = 0.5;
const FRAGMENT_TYPES = ['red', 'blue', 'green'];
const ENEMY_TYPES = ['drone', 'sentinel', 'charger', 'carrier'];

// Game State
let game = {
    state: 'menu',
    score: 0,
    wave: 1,
    enemies: [],
    projectiles: [],
    particles: [],
    fragments: [],
    powerups: [],
    player: null,
    lastWaveSpawn: 0,
    enemyCount: 0,
    keys: {},
    mouse: { x: 0, y: 0, shooting: false },
    specialActive: false,
    specialCooldown: 0,
    dashActive: false,
    dashCooldown: 0,
    frameCount: 0,
    highScores: JSON.parse(localStorage.getItem('neoCoreScores')) || [],
    joystick: { active: false, x: 0, y: 0, baseX: 0, baseY: 0, handleX: 0, handleY: 0 }
};

// Canvas Contexts
const canvas = document.getElementById('gameCanvas');
const uiCanvas = document.getElementById('uiCanvas');
const ctx = canvas.getContext('2d');
const uiCtx = uiCanvas.getContext('2d');

// Initialize canvas size based on screen
function initCanvasSize() {
    const container = document.getElementById('canvasWrapper');
    CANVAS_WIDTH = container.clientWidth;
    CANVAS_HEIGHT = container.clientHeight;
    
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    uiCanvas.width = CANVAS_WIDTH;
    uiCanvas.height = CANVAS_HEIGHT;
    
    // Update joystick position for mobile
    const joystick = document.getElementById('joystick');
    if (joystick) {
        const rect = joystick.getBoundingClientRect();
        game.joystick.baseX = rect.left + rect.width / 2;
        game.joystick.baseY = rect.top + rect.height / 2;
        game.joystick.handleX = game.joystick.baseX;
        game.joystick.handleY = game.joystick.baseY;
    }
}

// Utility Functions
function getRandomColor(type) {
    const colors = {
        red: '#ff3333',
        blue: '#3333ff',
        green: '#33ff33',
        drone: '#ff0000',
        sentinel: '#ff00ff',
        charger: '#ffff00',
        carrier: '#00ffff',
        player: '#00aaff',
        projectile: '#ffffff',
        particle: '#ff9900'
    };
    return colors[type] || '#ffffff';
}

function distance(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

function random(min, max) {
    return Math.random() * (max - min) + min;
}

function createParticle(x, y, color, count = 10) {
    for (let i = 0; i < count; i++) {
        game.particles.push({
            x, y,
            vx: random(-5, 5),
            vy: random(-5, 5),
            life: 30,
            color,
            radius: random(2, 5)
        });
    }
}

// Player Class
class Player {
    constructor() {
        this.x = CANVAS_WIDTH / 2;
        this.y = CANVAS_HEIGHT / 2;
        this.radius = PLAYER_RADIUS * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800);
        this.health = PLAYER_MAX_HEALTH;
        this.shield = PLAYER_MAX_SHIELD;
        this.fragments = { red: 0, blue: 0, green: 0 };
        this.weapon = 'basic';
        this.weaponCooldown = 0;
        this.specialCooldown = 0;
        this.dashCooldown = 0;
        this.lastShot = 0;
        this.invulnerable = 0;
    }

    update() {
        // Movement - Use joystick or keyboard
        let moveX = 0, moveY = 0;
        
        if (game.joystick.active) {
            moveX = game.joystick.x;
            moveY = game.joystick.y;
        } else {
            if (game.keys['ArrowLeft'] || game.keys['a']) moveX = -1;
            if (game.keys['ArrowRight'] || game.keys['d']) moveX = 1;
            if (game.keys['ArrowUp'] || game.keys['w']) moveY = -1;
            if (game.keys['ArrowDown'] || game.keys['s']) moveY = 1;
        }
        
        if (moveX !== 0 || moveY !== 0) {
            const length = Math.sqrt(moveX * moveX + moveY * moveY);
            if (length > 0) {
                moveX /= length;
                moveY /= length;
            }
        }
        
        let speed = PLAYER_SPEED;
        if (game.dashActive && game.dashCooldown === 0) {
            speed *= 3;
            game.dashCooldown = 30;
        }
        
        this.x += moveX * speed;
        this.y += moveY * speed;
        
        // Keep in bounds
        this.x = Math.max(this.radius, Math.min(CANVAS_WIDTH - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(CANVAS_HEIGHT - this.radius, this.y));
        
        // Shooting
        if (game.mouse.shooting && game.frameCount - this.lastShot > 5) {
            this.shoot();
            this.lastShot = game.frameCount;
        }
        
        // Cooldowns
        if (this.weaponCooldown > 0) this.weaponCooldown--;
        if (this.specialCooldown > 0) this.specialCooldown--;
        if (this.dashCooldown > 0) this.dashCooldown--;
        if (game.dashCooldown > 0) game.dashCooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
        
        // Shield regen
        if (this.shield < PLAYER_MAX_SHIELD && game.frameCount % 60 === 0) {
            this.shield = Math.min(PLAYER_MAX_SHIELD, this.shield + SHIELD_REGEN_RATE);
        }
    }

    shoot() {
        const dx = game.mouse.x - this.x;
        const dy = game.mouse.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
            const speed = 10;
            game.projectiles.push({
                x: this.x,
                y: this.y,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                radius: 4 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                damage: 10,
                type: 'player',
                color: getRandomColor('projectile')
            });
            
            if (this.weapon === 'missile' && this.weaponCooldown === 0) {
                for (let i = -1; i <= 1; i += 2) {
                    game.projectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: (dx / dist + i * 0.2) * speed * 0.8,
                        vy: (dy / dist) * speed * 0.8,
                        radius: 6 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                        damage: 15,
                        type: 'missile',
                        color: '#ff3333'
                    });
                }
                this.weaponCooldown = 20;
            }
        }
    }

    activateSpecial() {
        if (this.specialCooldown > 0 || game.specialCooldown > 0) return;
        
        const fragmentCounts = Object.values(this.fragments);
        const hasThreeOfAny = fragmentCounts.some(count => count >= 3);
        
        if (hasThreeOfAny) {
            game.specialActive = true;
            game.specialCooldown = 300;
            
            for (const color in this.fragments) {
                if (this.fragments[color] >= 3) {
                    this.fragments[color] -= 3;
                    break;
                }
            }
            
            if (this.fragments.red >= 3) {
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    game.projectiles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * 8,
                        vy: Math.sin(angle) * 8,
                        radius: 8 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                        damage: 20,
                        type: 'missileBarrage',
                        color: '#ff0000'
                    });
                }
            }
        }
    }

    takeDamage(amount) {
        if (this.invulnerable > 0) return;
        
        if (this.shield > 0) {
            this.shield = Math.max(0, this.shield - amount);
        } else {
            this.health = Math.max(0, this.health - amount);
            this.invulnerable = 30;
        }
        
        createParticle(this.x, this.y, '#ff0000', 5);
        
        if (this.health <= 0) {
            gameOver();
        }
    }

    draw() {
        ctx.save();
        
        if (this.invulnerable > 0 && Math.floor(this.invulnerable / 5) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        ctx.fillStyle = getRandomColor('player');
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = this.x + Math.cos(angle) * this.radius;
            const y = this.y + Math.sin(angle) * this.radius;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fill();
        
        ctx.shadowColor = getRandomColor('player');
        ctx.shadowBlur = 20;
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        const dx = game.mouse.x - this.x;
        const dy = game.mouse.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0) {
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + (dx / dist) * 30, this.y + (dy / dist) * 30);
            ctx.stroke();
        }
        
        ctx.restore();
    }
}

// Enemy Class
class Enemy {
    constructor(type, x, y) {
        this.type = type;
        this.x = x || random(50, CANVAS_WIDTH - 50);
        this.y = y || random(50, CANVAS_HEIGHT - 50);
        this.radius = this.getRadius() * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800);
        this.health = this.getHealth();
        this.speed = this.getSpeed();
        this.color = getRandomColor(type);
        this.lastShot = 0;
        this.shootDelay = this.getShootDelay();
        this.value = this.getValue();
    }

    getRadius() {
        const radii = { drone: 12, sentinel: 15, charger: 10, carrier: 25 };
        return radii[this.type] || 15;
    }

    getHealth() {
        const health = { drone: 20, sentinel: 30, charger: 15, carrier: 50 };
        return health[this.type] || 20;
    }

    getSpeed() {
        const speeds = { drone: 2, sentinel: 0, charger: 4, carrier: 1 };
        return speeds[this.type] || 2;
    }

    getShootDelay() {
        const delays = { drone: 60, sentinel: 30, charger: 999, carrier: 90 };
        return delays[this.type] || 60;
    }

    getValue() {
        const values = { drone: 10, sentinel: 20, charger: 15, carrier: 40 };
        return values[this.type] || 10;
    }

    update() {
        if (this.speed > 0) {
            const dx = game.player.x - this.x;
            const dy = game.player.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist > 0 && dist < 400) {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }
        }
        
        if (game.frameCount - this.lastShot > this.shootDelay) {
            this.shoot();
            this.lastShot = game.frameCount;
        }
        
        if (this.type === 'carrier' && game.frameCount % 180 === 0) {
            spawnEnemy('drone', this.x, this.y);
        }
    }

    shoot() {
        if (this.type === 'charger') return;
        
        const dx = game.player.x - this.x;
        const dy = game.player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0 && dist < 500) {
            const speed = 4;
            game.projectiles.push({
                x: this.x,
                y: this.y,
                vx: (dx / dist) * speed,
                vy: (dy / dist) * speed,
                radius: 6 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                damage: 5,
                type: 'enemy',
                color: this.color
            });
        }
    }

    takeDamage(amount) {
        this.health -= amount;
        
        createParticle(this.x, this.y, this.color, 3);
        
        if (this.health <= 0) {
            this.destroy();
            return true;
        }
        return false;
    }

    destroy() {
        game.score += this.value;
        
        if (Math.random() < 0.3) {
            const fragmentType = FRAGMENT_TYPES[Math.floor(Math.random() * FRAGMENT_TYPES.length)];
            game.fragments.push({
                x: this.x,
                y: this.y,
                type: fragmentType,
                radius: 8 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                color: getRandomColor(fragmentType),
                vx: random(-2, 2),
                vy: random(-2, 2),
                life: 600
            });
        }
        
        createParticle(this.x, this.y, this.color, 20);
        
        if (Math.random() < 0.1) {
            game.powerups.push({
                x: this.x,
                y: this.y,
                type: ['health', 'shield', 'speed'][Math.floor(Math.random() * 3)],
                radius: 10 * (Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800),
                color: '#ffffff'
            });
        }
        
        game.enemyCount--;
    }

    draw() {
        ctx.save();
        ctx.fillStyle = this.color;
        
        if (this.type === 'drone') {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x - this.radius, this.y + this.radius);
            ctx.lineTo(this.x + this.radius, this.y + this.radius);
            ctx.closePath();
            ctx.fill();
        } else if (this.type === 'sentinel') {
            ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
        } else if (this.type === 'charger') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'carrier') {
            ctx.beginPath();
            ctx.moveTo(this.x, this.y - this.radius);
            ctx.lineTo(this.x + this.radius, this.y);
            ctx.lineTo(this.x, this.y + this.radius);
            ctx.lineTo(this.x - this.radius, this.y);
            ctx.closePath();
            ctx.fill();
        }
        
        const healthPercent = this.health / this.getHealth();
        if (healthPercent < 1) {
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(this.x - this.radius, this.y - this.radius - 5, this.radius * 2 * healthPercent, 3);
        }
        
        ctx.restore();
    }
}

// Game Functions
function spawnEnemy(type, x, y) {
    game.enemies.push(new Enemy(type, x, y));
    game.enemyCount++;
}

function spawnWave() {
    const baseCount = 5 + game.wave * 2;
    const enemyTypes = [...ENEMY_TYPES];
    
    for (let i = 0; i < Math.min(baseCount, 30); i++) {
        const type = enemyTypes[Math.floor(Math.random() * Math.min(game.wave, enemyTypes.length))];
        spawnEnemy(type);
    }
    
    game.lastWaveSpawn = game.frameCount;
}

function updateGame() {
    game.frameCount++;
    
    if (game.player) {
        game.player.update();
        
        for (let i = game.fragments.length - 1; i >= 0; i--) {
            const frag = game.fragments[i];
            if (distance(game.player.x, game.player.y, frag.x, frag.y) < game.player.radius + frag.radius) {
                game.player.fragments[frag.type]++;
                createParticle(frag.x, frag.y, frag.color, 10);
                game.fragments.splice(i, 1);
            }
        }
        
        for (let i = game.powerups.length - 1; i >= 0; i--) {
            const p = game.powerups[i];
            if (distance(game.player.x, game.player.y, p.x, p.y) < game.player.radius + p.radius) {
                applyPowerup(p.type);
                createParticle(p.x, p.y, p.color, 15);
                game.powerups.splice(i, 1);
            }
        }
    }
    
    for (let i = game.enemies.length - 1; i >= 0; i--) {
        const enemy = game.enemies[i];
        enemy.update();
        
        if (distance(game.player.x, game.player.y, enemy.x, enemy.y) < game.player.radius + enemy.radius) {
            if (enemy.type === 'charger') {
                game.player.takeDamage(15);
                if (enemy.takeDamage(99)) {
                    game.enemies.splice(i, 1);
                }
            }
        }
    }
    
    for (let i = game.projectiles.length - 1; i >= 0; i--) {
        const proj = game.projectiles[i];
        proj.x += proj.vx;
        proj.y += proj.vy;
        
        if (proj.x < -50 || proj.x > CANVAS_WIDTH + 50 || proj.y < -50 || proj.y > CANVAS_HEIGHT + 50) {
            game.projectiles.splice(i, 1);
            continue;
        }
        
        if (proj.type === 'player' || proj.type.includes('missile')) {
            for (let j = game.enemies.length - 1; j >= 0; j--) {
                const enemy = game.enemies[j];
                if (distance(proj.x, proj.y, enemy.x, enemy.y) < proj.radius + enemy.radius) {
                    if (enemy.takeDamage(proj.damage)) {
                        game.enemies.splice(j, 1);
                    }
                    createParticle(proj.x, proj.y, proj.color, 5);
                    game.projectiles.splice(i, 1);
                    break;
                }
            }
        } else if (proj.type === 'enemy') {
            if (distance(proj.x, proj.y, game.player.x, game.player.y) < proj.radius + game.player.radius) {
                game.player.takeDamage(proj.damage);
                createParticle(proj.x, proj.y, proj.color, 5);
                game.projectiles.splice(i, 1);
            }
        }
    }
    
    for (let i = game.fragments.length - 1; i >= 0; i--) {
        const frag = game.fragments[i];
        frag.x += frag.vx;
        frag.y += frag.vy;
        frag.vx *= 0.98;
        frag.vy *= 0.98;
        frag.life--;
        
        if (frag.life <= 0) {
            game.fragments.splice(i, 1);
        }
    }
    
    for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.95;
        p.vy *= 0.95;
        
        if (p.life <= 0) {
            game.particles.splice(i, 1);
        }
    }
    
    if (game.enemyCount === 0 && game.frameCount - game.lastWaveSpawn > 180) {
        game.wave++;
        spawnWave();
    }
    
    if (game.specialActive) {
        game.specialCooldown--;
        if (game.specialCooldown <= 0) {
            game.specialActive = false;
        }
    }
}

function applyPowerup(type) {
    switch(type) {
        case 'health':
            game.player.health = Math.min(PLAYER_MAX_HEALTH, game.player.health + 25);
            break;
        case 'shield':
            game.player.shield = Math.min(PLAYER_MAX_SHIELD, game.player.shield + 25);
            break;
        case 'speed':
            // Speed boost effect
            break;
    }
}

function drawGame() {
    // Clear canvas
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Draw starfield background
    if (game.frameCount % 10 === 0) {
        if (game.particles.length < 100 && Math.random() < 0.1) {
            game.particles.push({
                x: random(0, CANVAS_WIDTH),
                y: random(0, CANVAS_HEIGHT),
                vx: 0,
                vy: 0.5,
                life: 1000,
                color: '#ffffff',
                radius: random(1, 2)
            });
        }
    }
    
    // Draw particles
    game.particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
    });
    
    // Draw fragments
    game.fragments.forEach(frag => {
        ctx.fillStyle = frag.color;
        ctx.beginPath();
        ctx.arc(frag.x, frag.y, frag.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowColor = frag.color;
        ctx.shadowBlur = 10;
        ctx.fill();
        ctx.shadowBlur = 0;
    });
    
    // Draw powerups
    game.powerups.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        
        const pulse = Math.sin(game.frameCount * 0.1) * 2;
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius + pulse, 0, Math.PI * 2);
        ctx.stroke();
    });
    
    // Draw projectiles
    game.projectiles.forEach(proj => {
        ctx.fillStyle = proj.color;
        ctx.beginPath();
        ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = proj.color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(proj.x, proj.y);
        ctx.lineTo(proj.x - proj.vx, proj.y - proj.vy);
        ctx.stroke();
    });
    
    // Draw enemies
    game.enemies.forEach(enemy => enemy.draw());
    
    // Draw player
    if (game.player) {
        game.player.draw();
    }
    
    // Draw UI
    drawUI();
}

function drawUI() {
    uiCtx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Health bar
    const barWidth = Math.min(200, CANVAS_WIDTH * 0.4);
    const barHeight = Math.min(20, CANVAS_HEIGHT * 0.03);
    const barX = 20;
    const barY = 20;
    
    // Health
    const healthPercent = game.player.health / PLAYER_MAX_HEALTH;
    uiCtx.fillStyle = '#330000';
    uiCtx.fillRect(barX, barY, barWidth, barHeight);
    uiCtx.fillStyle = '#ff0000';
    uiCtx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
    
    // Shield
    const shieldPercent = game.player.shield / PLAYER_MAX_SHIELD;
    const shieldY = barY + barHeight + 5;
    uiCtx.fillStyle = '#003333';
    uiCtx.fillRect(barX, shieldY, barWidth, barHeight);
    uiCtx.fillStyle = '#00ffff';
    uiCtx.fillRect(barX, shieldY, barWidth * shieldPercent, barHeight);
    
    // Labels
    uiCtx.fillStyle = '#ffffff';
    uiCtx.font = `${Math.min(14, CANVAS_HEIGHT * 0.02)}px Courier New`;
    uiCtx.fillText(`HEALTH: ${Math.round(game.player.health)}`, barX + 5, barY + barHeight * 0.8);
    uiCtx.fillText(`SHIELD: ${Math.round(game.player.shield)}`, barX + 5, shieldY + barHeight * 0.8);
    
    // Score and Wave
    uiCtx.fillStyle = '#00ff00';
    uiCtx.font = `${Math.min(20, CANVAS_HEIGHT * 0.03)}px Courier New`;
    uiCtx.fillText(`SCORE: ${game.score}`, CANVAS_WIDTH - barWidth - 20, 40);
    uiCtx.fillText(`WAVE: ${game.wave}`, CANVAS_WIDTH - barWidth - 20, 70);
    
    // Fragments
    const fragX = 20;
    const fragY = shieldY + barHeight + 25;
    uiCtx.fillStyle = '#ffffff';
    uiCtx.font = `${Math.min(16, CANVAS_HEIGHT * 0.025)}px Courier New`;
    uiCtx.fillText('FRAGMENTS:', fragX, fragY);
    
    FRAGMENT_TYPES.forEach((type, i) => {
        const count = game.player.fragments[type];
        uiCtx.fillStyle = getRandomColor(type);
        uiCtx.fillRect(fragX + 100 + i * 50, fragY - 15, 40, 20);
        uiCtx.fillStyle = '#ffffff';
        uiCtx.fillText(`${count}/3`, fragX + 110 + i * 50, fragY);
    });
    
    // Special ability indicator
    if (game.specialCooldown > 0) {
        const specialWidth = Math.min(200, CANVAS_WIDTH * 0.5);
        const specialHeight = Math.min(10, CANVAS_HEIGHT * 0.015);
        const specialX = CANVAS_WIDTH / 2 - specialWidth / 2;
        const specialY = CANVAS_HEIGHT - 40;
        
        const cooldownPercent = game.specialCooldown / 300;
        uiCtx.fillStyle = '#333333';
        uiCtx.fillRect(specialX, specialY, specialWidth, specialHeight);
        uiCtx.fillStyle = '#ff00ff';
        uiCtx.fillRect(specialX, specialY, specialWidth * (1 - cooldownPercent), specialHeight);
        
        uiCtx.fillStyle = '#ffffff';
        uiCtx.font = `${Math.min(12, CANVAS_HEIGHT * 0.02)}px Courier New`;
        uiCtx.fillText('SPECIAL COOLDOWN', specialX, specialY - 5);
    }
    
    // Dash indicator
    if (game.dashCooldown > 0) {
        const dashWidth = Math.min(100, CANVAS_WIDTH * 0.3);
        const dashHeight = Math.min(8, CANVAS_HEIGHT * 0.012);
        const dashX = 20;
        const dashY = CANVAS_HEIGHT - 30;
        
        const cooldownPercent = game.dashCooldown / 30;
        uiCtx.fillStyle = '#333300';
        uiCtx.fillRect(dashX, dashY, dashWidth, dashHeight);
        uiCtx.fillStyle = '#ffff00';
        uiCtx.fillRect(dashX, dashY, dashWidth * (1 - cooldownPercent), dashHeight);
    }
}

function gameOver() {
    game.state = 'gameOver';
    document.getElementById('finalScore').textContent = `Score: ${game.score}`;
    document.getElementById('finalWave').textContent = `Wave: ${game.wave}`;
    document.getElementById('gameOver').style.display = 'flex';
    
    saveHighScore(game.score, game.wave);
}

function saveHighScore(score, wave) {
    game.highScores.push({ score, wave, date: new Date().toLocaleDateString() });
    game.highScores.sort((a, b) => b.score - a.score);
    game.highScores = game.highScores.slice(0, 10);
    localStorage.setItem('neoCoreScores', JSON.stringify(game.highScores));
}

function displayHighScores() {
    const list = document.getElementById('highScoresList');
    list.innerHTML = '';
    
    game.highScores.forEach((hs, i) => {
        const li = document.createElement('li');
        li.textContent = `${i + 1}. ${hs.score} pts (Wave ${hs.wave}) - ${hs.date}`;
        list.appendChild(li);
    });
}

// Game Loop
function gameLoop() {
    if (game.state === 'playing') {
        updateGame();
        drawGame();
    }
    
    requestAnimationFrame(gameLoop);
}

// Event Handlers
function initEventHandlers() {
    // Mouse/Touch events for aiming
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        game.mouse.x = e.clientX - rect.left;
        game.mouse.y = e.clientY - rect.top;
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        game.mouse.x = touch.clientX - rect.left;
        game.mouse.y = touch.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', () => {
        game.mouse.shooting = true;
    });

    canvas.addEventListener('mouseup', () => {
        game.mouse.shooting = false;
    });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        game.mouse.shooting = true;
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        game.mouse.shooting = false;
    });

    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
    });

    // Joystick events
    const joystick = document.getElementById('joystick');
    const joystickHandle = document.getElementById('joystickHandle');
    
    joystick.addEventListener('touchstart', handleJoystickStart);
    joystick.addEventListener('touchmove', handleJoystickMove);
    joystick.addEventListener('touchend', handleJoystickEnd);
    
    joystick.addEventListener('mousedown', handleJoystickStart);
    document.addEventListener('mousemove', handleJoystickMove);
    document.addEventListener('mouseup', handleJoystickEnd);

    function handleJoystickStart(e) {
        e.preventDefault();
        game.joystick.active = true;
        updateJoystickPosition(e);
    }

    function handleJoystickMove(e) {
        if (!game.joystick.active) return;
        e.preventDefault();
        updateJoystickPosition(e);
    }

    function handleJoystickEnd(e) {
        e.preventDefault();
        game.joystick.active = false;
        game.joystick.x = 0;
        game.joystick.y = 0;
        joystickHandle.style.transform = 'translate(0, 0)';
    }

    function updateJoystickPosition(e) {
        const rect = joystick.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        let clientX, clientY;
        
        if (e.type.includes('touch')) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        const deltaX = clientX - centerX;
        const deltaY = clientY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = rect.width / 2 - joystickHandle.offsetWidth / 2;
        
        if (distance > maxDistance) {
            const angle = Math.atan2(deltaY, deltaX);
            game.joystick.x = Math.cos(angle);
            game.joystick.y = Math.sin(angle);
            joystickHandle.style.transform = `translate(${Math.cos(angle) * maxDistance}px, ${Math.sin(angle) * maxDistance}px)`;
        } else {
            game.joystick.x = deltaX / maxDistance;
            game.joystick.y = deltaY / maxDistance;
            joystickHandle.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
        }
    }

    // Keyboard events
    window.addEventListener('keydown', (e) => {
        game.keys[e.key] = true;
        
        if (game.state === 'playing') {
            switch(e.key) {
                case ' ':
                    game.dashActive = true;
                    break;
                case 'e':
                    if (game.player) game.player.activateSpecial();
                    break;
                case 'Escape':
                    pauseGame();
                    break;
            }
        }
        
        e.preventDefault();
    });

    window.addEventListener('keyup', (e) => {
        game.keys[e.key] = false;
        
        if (e.key === ' ') {
            game.dashActive = false;
        }
    });

    // Prevent default touch behaviors
    document.addEventListener('touchmove', (e) => {
        if (e.scale !== 1) {
            e.preventDefault();
        }
    }, { passive: false });

    // Prevent zoom
    document.addEventListener('gesturestart', (e) => {
        e.preventDefault();
    });
}

// UI Functions
function startGame() {
    initCanvasSize();
    
    game = {
        state: 'playing',
        score: 0,
        wave: 1,
        enemies: [],
        projectiles: [],
        particles: [],
        fragments: [],
        powerups: [],
        player: new Player(),
        lastWaveSpawn: 0,
        enemyCount: 0,
        keys: {},
        mouse: { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2, shooting: false },
        specialActive: false,
        specialCooldown: 0,
        dashActive: false,
        dashCooldown: 0,
        frameCount: 0,
        highScores: game.highScores,
        joystick: { active: false, x: 0, y: 0, baseX: 0, baseY: 0, handleX: 0, handleY: 0 }
    };
    
    spawnWave();
    
    document.getElementById('menu').style.display = 'none';
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('pauseScreen').style.display = 'none';
    document.getElementById('instructions').style.display = 'none';
    document.getElementById('highScores').style.display = 'none';
    
    // Show mobile controls
    if (isMobileDevice()) {
        document.getElementById('mobileControls').style.display = 'flex';
        document.getElementById('movementControls').style.display = 'block';
    }
}

function showMenu() {
    game.state = 'menu';
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('pauseScreen').style.display = 'none';
    document.getElementById('instructions').style.display = 'none';
    document.getElementById('highScores').style.display = 'none';
    document.getElementById('mobileControls').style.display = 'none';
    document.getElementById('movementControls').style.display = 'none';
}

function showInstructions() {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('instructions').style.display = 'block';
}

function closeInstructions() {
    document.getElementById('instructions').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
}

function showHighScores() {
    displayHighScores();
    document.getElementById('menu').style.display = 'none';
    document.getElementById('highScores').style.display = 'block';
}

function closeHighScores() {
    document.getElementById('highScores').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
}

function pauseGame() {
    if (game.state === 'playing') {
        game.state = 'paused';
        document.getElementById('pauseScreen').style.display = 'flex';
    }
}

function resumeGame() {
    game.state = 'playing';
    document.getElementById('pauseScreen').style.display = 'none';
}

function restartGame() {
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('pauseScreen').style.display = 'none';
    startGame();
}

// Mobile controls
function mobileShoot(start) {
    game.mouse.shooting = start;
}

function mobileDash(start) {
    game.dashActive = start;
}

function mobileSpecial(start) {
    if (start && game.player) {
        game.player.activateSpecial();
    }
}

// Device detection
function isMobileDevice() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}

// Initialize
function init() {
    initCanvasSize();
    initEventHandlers();
    
    // Set initial mouse position to center
    game.mouse.x = CANVAS_WIDTH / 2;
    game.mouse.y = CANVAS_HEIGHT / 2;
    
    // Start game loop
    gameLoop();
    
    // Show menu initially
    showMenu();
    
    // Handle resize
    window.addEventListener('resize', () => {
        initCanvasSize();
        if (game.player && game.state === 'playing') {
            // Keep player in bounds after resize
            game.player.x = Math.max(game.player.radius, Math.min(CANVAS_WIDTH - game.player.radius, game.player.x));
            game.player.y = Math.max(game.player.radius, Math.min(CANVAS_HEIGHT - game.player.radius, game.player.y));
        }
    });
    
    // Prevent pull-to-refresh on mobile
    document.body.addEventListener('touchmove', (e) => {
        if (game.state === 'playing') {
            e.preventDefault();
        }
    }, { passive: false });
}

// Start everything when page loads
window.addEventListener('load', init);
    </script>
</body>
</html>